====== TextBuffer ======
==== T ====
=== inherits from ===
  * [[..:..:Gtk:GObject:Object#T|Gtk.GObject.Object.T]]

  You may wish to begin by reading the text widget conceptual overview which gives an overview of all
  the objects and data types related to the text widget and how they work together.
  

==== :UnregisterSerializeFormat ====
'':UnregisterSerializeFormat(self @ [[#T|T]], format @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function unregisters a rich text format that was previously registered using
  gtk_text_buffer_register_serialize_format() or gtk_text_buffer_register_serialize_tagset()
  
  buffer : a GtkTextBuffer
  format : a GdkAtom representing a registered rich text format.
  

==== :UnregisterDeserializeFormat ====
'':UnregisterDeserializeFormat(self @ [[#T|T]], format @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function unregisters a rich text format that was previously registered using
  gtk_text_buffer_register_deserialize_format() or gtk_text_buffer_register_deserialize_tagset().
  
  buffer : a GtkTextBuffer
  format : a GdkAtom representing a registered rich text format.
  

==== :TagTable ====
'':TagTable(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TextTagTable#T|Gtk.Gtk.TextTagTable.T]]''


==== :Btree ====
'':Btree(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TextBTree#T|Gtk.Gtk.TextBTree.T]]''


==== :ClipboardContentsBuffers ====
'':ClipboardContentsBuffers(self @ [[#T|T]]) : [[..:..:Std:Object#T|Std.Object.T]]''


==== :SelectionClipboards ====
'':SelectionClipboards(self @ [[#T|T]]) : [[..:..:Std:Object#T|Std.Object.T]]''


==== :LogAttrCache ====
'':LogAttrCache(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TextLogAttrCache#T|Gtk.Gtk.TextLogAttrCache.T]]''


==== :UserActionCount ====
'':UserActionCount(self @ [[#T|T]]) : [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]''


==== :Modified ====
'':Modified(self @ [[#T|T]]) : [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]''


==== :HasSelection ====
'':HasSelection(self @ [[#T|T]]) : [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]''


==== :AddMark ====
'':AddMark(self @ [[#T|T]], mark @ [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]], where @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Adds the mark at position where. The mark must not be added to another buffer, and if its name is not NULL then there
  must not be another mark in the buffer with the same name.
  Emits the "mark_set" signal as notification of the mark's initial placement.
  
  buffer : a GtkTextBuffer
  mark :   the mark to add
  where :  location to place mark
  

==== :AddSelectionClipboard ====
'':AddSelectionClipboard(self @ [[#T|T]], clipboard @ [[..:..:Gtk:Gtk:Clipboard#T|Gtk.Gtk.Clipboard.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Adds clipboard to the list of clipboards in which the selection contents of buffer are available. In most cases,
  clipboard will be the GtkClipboard of type GDK_SELECTION_PRIMARY for a view of buffer.
  
  buffer :    a GtkTextBuffer
  clipboard : a GtkClipboard
  

==== :ApplyTag ====
'':ApplyTag(self @ [[#T|T]], tag @ [[..:..:Gtk:Gtk:TextTag#T|Gtk.Gtk.TextTag.T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Emits the "apply_tag" signal on buffer. The default handler for the signal applies tag to the given range. start and end
  do not have to be in order.
  
  buffer : a GtkTextBuffer
  tag :    a GtkTextTag
  start :  one bound of range to be tagged
  end :    other bound of range to be tagged
  

==== :ApplyTagByName ====
'':ApplyTagByName(self @ [[#T|T]], name @ [[..:..:Std:String#T|Std.String.T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Calls gtk_text_tag_table_lookup() on the buffer's tag table to get a GtkTextTag, then calls gtk_text_buffer_apply_tag().
  
  buffer : a GtkTextBuffer
  name :   name of a named GtkTextTag
  start :  one bound of range to be tagged
  end :    other bound of range to be tagged
  

==== :Backspace ====
'':Backspace(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], interactive @ [[..:..:Std:Symbol#T|Std.Symbol.T]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Performs the appropriate action as if the user hit the delete key with the cursor at the position specified by iter. In
  the normal case a single character will be deleted, but when combining accents are involved, more than one character can
  be deleted, and when precomposed character and accent combinations are involved, less than one character will be
  deleted.
  Because the buffer is modified, all outstanding iterators become invalid after calling this function; however, the iter
  will be re-initialized to point to the location where text was deleted.
  
  buffer :           a GtkTextBuffer
  iter :             a position in buffer
  interactive :      whether the deletion is caused by user interaction
  default_editable : whether the buffer is editable by default
  Returns :          TRUE if the buffer was modified
  

==== :BeginUserAction ====
'':BeginUserAction(self @ [[#T|T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Called to indicate that the buffer operations between here and a call to gtk_text_buffer_end_user_action() are part of a
  single user-visible operation. The operations between gtk_text_buffer_begin_user_action() and
  gtk_text_buffer_end_user_action() can then be grouped when creating an undo stack. GtkTextBuffer maintains a count of
  calls to gtk_text_buffer_begin_user_action() that have not been closed with a call to gtk_text_buffer_end_user_action(),
  and emits the "begin_user_action" and "end_user_action" signals only for the outermost pair of calls. This allows you to
  build user actions from other user actions.
  The "interactive" buffer mutation functions, such as gtk_text_buffer_insert_interactive(), automatically call begin/end
  user action around the buffer operations they perform, so there's no need to add extra calls if you user action consists
  solely of a single call to one of those functions.
  
  buffer : a GtkTextBuffer
  

==== :CopyClipboard ====
'':CopyClipboard(self @ [[#T|T]], clipboard @ [[..:..:Gtk:Gtk:Clipboard#T|Gtk.Gtk.Clipboard.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Copies the currently-selected text to a clipboard.
  
  buffer :    a GtkTextBuffer
  clipboard : the GtkClipboard object to copy to
  

==== :CreateChildAnchor ====
'':CreateChildAnchor(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Gtk:Gtk:TextChildAnchor#T|Gtk.Gtk.TextChildAnchor.T]]''

  This is a convenience function which simply creates a child anchor with gtk_text_child_anchor_new() and inserts it into
  the buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is owned by the buffer; no reference count is
  returned to the caller of gtk_text_buffer_create_child_anchor().
  
  buffer :  a GtkTextBuffer
  iter :    location in the buffer
  Returns : the created child anchor
  

==== :CreateMark ====
'':CreateMark(self @ [[#T|T]], mark_name @ [[..:..:Std:String#T|Std.String.T]], where @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], left_gravity @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]]''

  Creates a mark at position where. If mark_name is NULL, the mark is anonymous; otherwise, the mark can be retrieved by
  name using gtk_text_buffer_get_mark(). If a mark has left gravity, and text is inserted at the mark's current location,
  the mark will be moved to the left of the newly-inserted text. If the mark has right gravity (left_gravity = FALSE), the
  mark will end up on the right of newly-inserted text. The standard left-to-right cursor is a mark with right gravity
  (when you type, the cursor stays on the right side of the text you're typing).
  The caller of this function does not own a reference to the returned GtkTextMark, so you can ignore the return value if
  you like. Marks are owned by the buffer and go away when the buffer does.
  Emits the "mark_set" signal as notification of the mark's initial placement.
  
  buffer :       a GtkTextBuffer
  mark_name :    name for mark, or NULL
  where :        location to place mark
  left_gravity : whether the mark has left gravity
  Returns :      the new GtkTextMark object
  

==== :CreateTag ====
'':CreateTag(self @ [[#T|T]], tag_name @ [[..:..:Std:String#T|Std.String.T]], first_property_name @ [[..:..:Std:String#T|Std.String.T]], __etc__ @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Gtk:Gtk:TextTag#T|Gtk.Gtk.TextTag.T]]''

  Creates a tag and adds it to the tag table for buffer. Equivalent to calling gtk_text_tag_new() and then adding the tag
  to the buffer's tag table. The returned tag is owned by the buffer's tag table, so the ref count will be equal to one.
  If tag_name is NULL, the tag is anonymous.
  If tag_name is non-NULL, a tag called tag_name must not already exist in the tag table for this buffer.
  The first_property_name argument and subsequent arguments are a list of properties to set on the tag, as with
  g_object_set().
  
  buffer :              a GtkTextBuffer
  tag_name :            name of the new tag, or NULL
  first_property_name : name of first property to set, or NULL
  ... :                 NULL-terminated list of property names and values
  Returns :             a new tag
  

==== :CutClipboard ====
'':CutClipboard(self @ [[#T|T]], clipboard @ [[..:..:Gtk:Gtk:Clipboard#T|Gtk.Gtk.Clipboard.T]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Copies the currently-selected text to a clipboard, then deletes said text if it's editable.
  
  buffer :           a GtkTextBuffer
  clipboard :        the GtkClipboard object to cut to
  default_editable : default editability of the buffer
  

==== :Delete ====
'':Delete(self @ [[#T|T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Deletes text between start and end. The order of start and end is not actually relevant; gtk_text_buffer_delete() will
  reorder them. This function actually emits the "delete_range" signal, and the default handler of that signal deletes the
  text. Because the buffer is modified, all outstanding iterators become invalid after calling this function; however, the
  start and end will be re-initialized to point to the location where text was deleted.
  
  buffer : a GtkTextBuffer
  start :  a position in buffer
  end :    another position in buffer
  

==== :DeleteInteractive ====
'':DeleteInteractive(self @ [[#T|T]], start_iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end_iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Deletes all editable text in the given range. Calls gtk_text_buffer_delete() for each editable sub-range of [start,end).
  start and end are revalidated to point to the location of the last deleted range, or left untouched if no text was
  deleted.
  
  buffer :           a GtkTextBuffer
  start_iter :       start of range to delete
  end_iter :         end of range
  default_editable : whether the buffer is editable by default
  Returns :          whether some text was actually deleted
  

==== :DeleteMark ====
'':DeleteMark(self @ [[#T|T]], mark @ [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Deletes mark, so that it's no longer located anywhere in the buffer. Removes the reference the buffer holds to the mark,
  so if you haven't called g_object_ref() on the mark, it will be freed. Even if the mark isn't freed, most operations on
  mark become invalid, until it gets added to a buffer again with gtk_text_buffer_add_mark(). Use
  gtk_text_mark_get_deleted() to find out if a mark has been removed from its buffer. The "mark_deleted" signal will be
  emitted as notification after the mark is deleted.
  
  buffer : a GtkTextBuffer
  mark :   a GtkTextMark in buffer
  

==== :DeleteMarkByName ====
'':DeleteMarkByName(self @ [[#T|T]], name @ [[..:..:Std:String#T|Std.String.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Deletes the mark named name; the mark must exist. See gtk_text_buffer_delete_mark() for details.
  
  buffer : a GtkTextBuffer
  name :   name of a mark in buffer
  

==== :DeleteSelection ====
'':DeleteSelection(self @ [[#T|T]], interactive @ [[..:..:Std:Symbol#T|Std.Symbol.T]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Deletes the range between the "insert" and "selection_bound" marks, that is, the currently-selected text. If interactive
  is TRUE, the editability of the selection will be considered (users can't delete uneditable text).
  
  buffer :           a GtkTextBuffer
  interactive :      whether the deletion is caused by user interaction
  default_editable : whether the buffer is editable by default
  Returns :          whether there was a non-empty selection to delete
  

==== :Deserialize ====
'':Deserialize(self @ [[#T|T]], content_buffer @ [[..:..:Gtk:Gtk:TextBuffer#T|Gtk.Gtk.TextBuffer.T]], format @ [[..:..:Std:Object#T|Std.Object.T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], data @ [[..:..:Std:Object#T|Std.Object.T]], length @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]], error @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  This function deserializes rich text in format format and inserts it at iter.
  formats to be used must be registered using gtk_text_buffer_register_deserialize_format() or
  gtk_text_buffer_register_deserialize_tagset() beforehand.
  
  register_buffer : the GtkTextBuffer format is registered with
  content_buffer :  the GtkTextBuffer to deserialize into
  format :          the rich text format to use for deserializing
  iter :            insertion point for the deserialized text
  data :            data to deserialize
  length :          length of data
  error :           return location for a GError
  Returns :         TRUE on success, FALSE otherwise.
  

==== :DeserializeGetCanCreateTags ====
'':DeserializeGetCanCreateTags(self @ [[#T|T]], format @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  This functions returns the value set with gtk_text_buffer_deserialize_set_can_create_tags()
  
  buffer :  a GtkTextBuffer
  format :  a GdkAtom representing a registered rich text format
  Returns : whether deserializing this format may create tags
  

==== :DeserializeSetCanCreateTags ====
'':DeserializeSetCanCreateTags(self @ [[#T|T]], format @ [[..:..:Std:Object#T|Std.Object.T]], can_create_tags @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Use this function to allow a rich text deserialization function to create new tags in the receiving buffer. Note that
  using this function is almost always a bad idea, because the rich text functions you register should know how to map the
  rich text format they handler to your text buffers set of tags.
  The ability of creating new (arbitrary!) tags in the receiving buffer is meant for special rich text formats like the
  internal one that is registered using gtk_text_buffer_register_deserialize_tagset(), because that format is essentially
  a dump of the internal structure of the source buffer, including its tag names.
  You should allow creation of tags only if you know what you are doing, e.g. if you defined a tagset name for your
  application suite's text buffers and you know that it's fine to receive new tags from these buffers, because you know
  that your application can handle the newly created tags.
  
  buffer :          a GtkTextBuffer
  format :          a GdkAtom representing a registered rich text format
  can_create_tags : whether deserializing this format may create tags
  

==== :EndUserAction ====
'':EndUserAction(self @ [[#T|T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Should be paired with a call to gtk_text_buffer_begin_user_action(). See that function for a full explanation.
  
  buffer : a GtkTextBuffer
  

==== :GetBounds ====
'':GetBounds(self @ [[#T|T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Retrieves the first and last iterators in the buffer, i.e. the entire buffer lies within the range [start,end).
  
  buffer : a GtkTextBuffer
  start :  iterator to initialize with first position in the buffer
  end :    iterator to initialize with the end iterator
  

==== :GetCharCount ====
'':GetCharCount(self @ [[#T|T]]) : [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]''

  Gets the number of characters in the buffer; note that characters and bytes are not the same, you can't e.g. expect the
  contents of the buffer in string form to be this many bytes long. The character count is cached, so this function is
  very fast.
  
  buffer :  a GtkTextBuffer
  Returns : number of characters in the buffer
  

==== :GetCopyTargetList ====
'':GetCopyTargetList(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TargetList#T|Gtk.Gtk.TargetList.T]]''

  This function returns the list of targets this text buffer can provide for copying and as DND source. The targets in the
  list are added with info values from the GtkTextBufferTargetInfo enum, using gtk_target_list_add_rich_text_targets() and
  gtk_target_list_add_text_targets().
  
  buffer :  a GtkTextBuffer
  Returns : the GtkTargetList
  

==== :GetDeserializeFormats ====
'':GetDeserializeFormats(self @ [[#T|T]], n_formats @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Gtk:Gdk:Atom#T|Gtk.Gdk.Atom.T]]''

  This function returns the rich text deserialize formats registered with buffer using
  gtk_text_buffer_register_deserialize_format() or gtk_text_buffer_register_deserialize_tagset()
  
  buffer :    a GtkTextBuffer
  n_formats : return location for the number of formats
  Returns :   an array of GdkAtoms representing the registered formats.
  

==== :GetEndIter ====
'':GetEndIter(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Initializes iter with the "end iterator," one past the last valid character in the text buffer. If dereferenced with
  gtk_text_iter_get_char(), the end iterator has a character value of 0. The entire buffer lies in the range from the
  first position in the buffer (call gtk_text_buffer_get_start_iter() to get character position 0) to the end iterator.
  
  buffer : a GtkTextBuffer
  iter :   iterator to initialize
  

==== :GetHasSelection ====
'':GetHasSelection(self @ [[#T|T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Indicates whether the buffer has some text currently selected.
  
  buffer :  a GtkTextBuffer
  Returns : TRUE if the there is text selected
  

==== :GetInsert ====
'':GetInsert(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]]''

  Returns the mark that represents the cursor (insertion point). Equivalent to calling gtk_text_buffer_get_mark() to get
  the mark named "insert", but very slightly more efficient, and involves less typing.
  
  buffer :  a GtkTextBuffer
  Returns : insertion point mark
  

==== :GetIterAtChildAnchor ====
'':GetIterAtChildAnchor(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], anchor @ [[..:..:Gtk:Gtk:TextChildAnchor#T|Gtk.Gtk.TextChildAnchor.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Obtains the location of anchor within buffer.
  
  buffer : a GtkTextBuffer
  iter :   an iterator to be initialized
  anchor : a child anchor that appears in buffer
  

==== :GetIterAtLine ====
'':GetIterAtLine(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], line_number @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Initializes iter to the start of the given line.
  
  buffer :      a GtkTextBuffer
  iter :        iterator to initialize
  line_number : line number counting from 0
  

==== :GetIterAtLineIndex ====
'':GetIterAtLineIndex(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], line_number @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]], byte_index @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Obtains an iterator pointing to byte_index within the given line. byte_index must be the start of a UTF-8 character, and
  must not be beyond the end of the line. Note bytes, not characters; UTF-8 may encode one character as multiple bytes.
  
  buffer :      a GtkTextBuffer
  iter :        iterator to initialize
  line_number : line number counting from 0
  byte_index :  byte index from start of line
  

==== :GetIterAtLineOffset ====
'':GetIterAtLineOffset(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], line_number @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]], char_offset @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Obtains an iterator pointing to char_offset within the given line. The char_offset must exist, offsets off the end of
  the line are not allowed. Note characters, not bytes; UTF-8 may encode one character as multiple bytes.
  
  buffer :      a GtkTextBuffer
  iter :        iterator to initialize
  line_number : line number counting from 0
  char_offset : char offset from start of line
  

==== :GetIterAtMark ====
'':GetIterAtMark(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], mark @ [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Initializes iter with the current position of mark.
  
  buffer : a GtkTextBuffer
  iter :   iterator to initialize
  mark :   a GtkTextMark in buffer
  

==== :GetIterAtOffset ====
'':GetIterAtOffset(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], char_offset @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Initializes iter to a position char_offset chars from the start of the entire buffer. If char_offset is -1 or greater
  than the number of characters in the buffer, iter is initialized to the end iterator, the iterator one past the last
  valid character in the buffer.
  
  buffer :      a GtkTextBuffer
  iter :        iterator to initialize
  char_offset : char offset from start of buffer, counting from 0, or -1
  

==== :GetLineCount ====
'':GetLineCount(self @ [[#T|T]]) : [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]''

  Obtains the number of lines in the buffer. This value is cached, so the function is very fast.
  
  buffer :  a GtkTextBuffer
  Returns : number of lines in the buffer
  

==== :GetMark ====
'':GetMark(self @ [[#T|T]], name @ [[..:..:Std:String#T|Std.String.T]]) : [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]]''

  Returns the mark named name in buffer buffer, or NULL if no such mark exists in the buffer.
  
  buffer :  a GtkTextBuffer
  name :    a mark name
  Returns : a GtkTextMark, or NULL
  

==== :GetModified ====
'':GetModified(self @ [[#T|T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Indicates whether the buffer has been modified since the last call to gtk_text_buffer_set_modified() set the
  modification flag to FALSE. Used for example to enable a "save" function in a text editor.
  
  buffer :  a GtkTextBuffer
  Returns : TRUE if the buffer has been modified
  

==== :GetPasteTargetList ====
'':GetPasteTargetList(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TargetList#T|Gtk.Gtk.TargetList.T]]''

  This function returns the list of targets this text buffer supports for pasting and as DND destination. The targets in
  the list are added with info values from the GtkTextBufferTargetInfo enum, using gtk_target_list_add_rich_text_targets()
  and gtk_target_list_add_text_targets().
  
  buffer :  a GtkTextBuffer
  Returns : the GtkTargetList
  

==== :GetSelectionBound ====
'':GetSelectionBound(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]]''

  Returns the mark that represents the selection bound. Equivalent to calling gtk_text_buffer_get_mark() to get the mark
  named "selection_bound", but very slightly more efficient, and involves less typing.
  The currently-selected text in buffer is the region between the "selection_bound" and "insert" marks. If
  "selection_bound" and "insert" are in the same place, then there is no current selection.
  gtk_text_buffer_get_selection_bounds() is another convenient function for handling the selection, if you just want to
  know whether there's a selection and what its bounds are.
  
  buffer :  a GtkTextBuffer
  Returns : selection bound mark
  

==== :GetSelectionBounds ====
'':GetSelectionBounds(self @ [[#T|T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Returns TRUE if some text is selected; places the bounds of the selection in start and end (if the selection has length
  0, then start and end are filled in with the same value). start and end will be in ascending order. If start and end are
  NULL, then they are not filled in, but the return value still indicates whether text is selected.
  
  buffer :  a GtkTextBuffer a GtkTextBuffer
  start :   iterator to initialize with selection start
  end :     iterator to initialize with selection end
  Returns : whether the selection has nonzero length
  

==== :GetSerializeFormats ====
'':GetSerializeFormats(self @ [[#T|T]], n_formats @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Gtk:Gdk:Atom#T|Gtk.Gdk.Atom.T]]''

  This function returns the rich text serialize formats registered with buffer using
  gtk_text_buffer_register_serialize_format() or gtk_text_buffer_register_serialize_tagset()
  
  buffer :    a GtkTextBuffer
  n_formats : return location for the number of formats
  Returns :   an array of GdkAtoms representing the registered formats.
  

==== :GetSlice ====
'':GetSlice(self @ [[#T|T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], include_hidden_chars @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:String#T|Std.String.T]]''

  Returns the text in the range [start,end). Excludes undisplayed text (text marked with tags that set the invisibility
  attribute) if include_hidden_chars is FALSE. The returned string includes a 0xFFFC character whenever the buffer
  contains embedded images, so byte and character indexes into the returned string do correspond to byte and character
  indexes into the buffer. Contrast with gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as well, so
  it is not a reliable indicator that a pixbuf or widget is in the buffer.
  
  buffer :               a GtkTextBuffer
  start :                start of a range
  end :                  end of a range
  include_hidden_chars : whether to include invisible text
  Returns :              an allocated UTF-8 string
  

==== :GetStartIter ====
'':GetStartIter(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Initialized iter with the first position in the text buffer. This is the same as using
  gtk_text_buffer_get_iter_at_offset() to get the iter at character offset 0.
  
  buffer : a GtkTextBuffer
  iter :   iterator to initialize
  

==== :GetTagTable ====
'':GetTagTable(self @ [[#T|T]]) : [[..:..:Gtk:Gtk:TextTagTable#T|Gtk.Gtk.TextTagTable.T]]''

  Get the GtkTextTagTable associated with this buffer.
  
  buffer :  a GtkTextBuffer
  Returns : the buffer's tag table
  

==== :GetText ====
'':GetText(self @ [[#T|T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], include_hidden_chars @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:String#T|Std.String.T]]''

  Returns the text in the range [start,end). Excludes undisplayed text (text marked with tags that set the invisibility
  attribute) if include_hidden_chars is FALSE. Does not include characters representing embedded images, so byte and
  character indexes into the returned string do not correspond to byte and character indexes into the buffer. Contrast
  with gtk_text_buffer_get_slice().
  
  buffer :               a GtkTextBuffer
  start :                start of a range
  end :                  end of a range
  include_hidden_chars : whether to include invisible text
  Returns :              an allocated UTF-8 string
  

==== :Insert ====
'':Insert(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], text @ [[..:..:Std:String#T|Std.String.T]], len @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Inserts len bytes of text at position iter. If len is -1, text must be nul-terminated and will be inserted in its
  entirety. Emits the "insert_text" signal; insertion actually occurs in the default handler for the signal. iter is
  invalidated when insertion occurs (because the buffer contents change), but the default signal handler revalidates it to
  point to the end of the inserted text.
  
  buffer : a GtkTextBuffer
  iter :   a position in the buffer
  text :   UTF-8 format text to insert
  len :    length of text in bytes, or -1
  

==== :InsertAtCursor ====
'':InsertAtCursor(self @ [[#T|T]], text @ [[..:..:Std:String#T|Std.String.T]], len @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Simply calls gtk_text_buffer_insert(), using the current cursor position as the insertion point.
  
  buffer : a GtkTextBuffer
  text :   some text in UTF-8 format
  len :    length of text, in bytes
  

==== :InsertChildAnchor ====
'':InsertChildAnchor(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], anchor @ [[..:..:Gtk:Gtk:TextChildAnchor#T|Gtk.Gtk.TextChildAnchor.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Inserts a child widget anchor into the text buffer at iter. The anchor will be counted as one character in character
  counts, and when obtaining the buffer contents as a string, will be represented by the Unicode "object replacement
  character" 0xFFFC. Note that the "slice" variants for obtaining portions of the buffer as a string include this
  character for child anchors, but the "text" variants do not. E.g. see gtk_text_buffer_get_slice() and
  gtk_text_buffer_get_text(). Consider gtk_text_buffer_create_child_anchor() as a more convenient alternative to this
  function. The buffer will add a reference to the anchor, so you can unref it after insertion.
  
  buffer : a GtkTextBuffer
  iter :   location to insert the anchor
  anchor : a GtkTextChildAnchor
  

==== :InsertInteractive ====
'':InsertInteractive(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], text @ [[..:..:Std:String#T|Std.String.T]], len @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Like gtk_text_buffer_insert(), but the insertion will not occur if iter is at a non-editable location in the buffer.
  Usually you want to prevent insertions at ineditable locations if the insertion results from a user action (is
  interactive).
  default_editable indicates the editability of text that doesn't have a tag affecting editability applied to it.
  Typically the result of gtk_text_view_get_editable() is appropriate here.
  
  buffer :           a GtkTextBuffer
  iter :             a position in buffer
  text :             some UTF-8 text
  len :              length of text in bytes, or -1
  default_editable : default editability of buffer
  Returns :          whether text was actually inserted
  

==== :InsertInteractiveAtCursor ====
'':InsertInteractiveAtCursor(self @ [[#T|T]], text @ [[..:..:Std:String#T|Std.String.T]], len @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Calls gtk_text_buffer_insert_interactive() at the cursor position.
  default_editable indicates the editability of text that doesn't have a tag affecting editability applied to it.
  Typically the result of gtk_text_view_get_editable() is appropriate here.
  
  buffer :           a GtkTextBuffer
  text :             text in UTF-8 format
  len :              length of text in bytes, or -1
  default_editable : default editability of buffer
  Returns :          whether text was actually inserted
  

==== :InsertPixbuf ====
'':InsertPixbuf(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], pixbuf @ [[..:..:Gtk:Gdk:Pixbuf#T|Gtk.Gdk.Pixbuf.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Inserts an image into the text buffer at iter. The image will be counted as one character in character counts, and when
  obtaining the buffer contents as a string, will be represented by the Unicode "object replacement character" 0xFFFC.
  Note that the "slice" variants for obtaining portions of the buffer as a string include this character for pixbufs, but
  the "text" variants do not. e.g. see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
  
  buffer : a GtkTextBuffer
  iter :   location to insert the pixbuf
  pixbuf : a GdkPixbuf
  

==== :InsertRange ====
'':InsertRange(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Copies text, tags, and pixbufs between start and end (the order of start and end doesn't matter) and inserts the copy at
  iter. Used instead of simply getting/inserting text because it preserves images and tags. If start and end are in a
  different buffer from buffer, the two buffers must share the same tag table.
  Implemented via emissions of the insert_text and apply_tag signals, so expect those.
  
  buffer : a GtkTextBuffer
  iter :   a position in buffer
  start :  a position in a GtkTextBuffer
  end :    another position in the same buffer as start
  

==== :InsertRangeInteractive ====
'':InsertRangeInteractive(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Symbol#T|Std.Symbol.T]]''

  Same as gtk_text_buffer_insert_range(), but does nothing if the insertion point isn't editable. The default_editable
  parameter indicates whether the text is editable at iter if no tags enclosing iter affect editability. Typically the
  result of gtk_text_view_get_editable() is appropriate here.
  
  buffer :           a GtkTextBuffer
  iter :             a position in buffer
  start :            a position in a GtkTextBuffer
  end :              another position in the same buffer as start
  default_editable : default editability of the buffer
  Returns :          whether an insertion was possible at iter
  

==== :InsertWithTags ====
'':InsertWithTags(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], text @ [[..:..:Std:String#T|Std.String.T]], len @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]], first_tag @ [[..:..:Gtk:Gtk:TextTag#T|Gtk.Gtk.TextTag.T]], __etc__ @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Inserts text into buffer at iter, applying the list of tags to the newly-inserted text. The last tag specified must be
  NULL to terminate the list. Equivalent to calling gtk_text_buffer_insert(), then gtk_text_buffer_apply_tag() on the
  inserted text; gtk_text_buffer_insert_with_tags() is just a convenience function.
  
  buffer :    a GtkTextBuffer
  iter :      an iterator in buffer
  text :      UTF-8 text
  len :       length of text, or -1
  first_tag : first tag to apply to text
  ... :       NULL-terminated list of tags to apply
  

==== :InsertWithTagsByName ====
'':InsertWithTagsByName(self @ [[#T|T]], iter @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], text @ [[..:..:Std:String#T|Std.String.T]], len @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]], first_tag_name @ [[..:..:Std:String#T|Std.String.T]], __etc__ @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Same as gtk_text_buffer_insert_with_tags(), but allows you to pass in tag names instead of tag objects.
  
  buffer :         a GtkTextBuffer
  iter :           position in buffer
  text :           UTF-8 text
  len :            length of text, or -1
  first_tag_name : name of a tag to apply to text
  ... :            more tag names
  

==== :MoveMark ====
'':MoveMark(self @ [[#T|T]], mark @ [[..:..:Gtk:Gtk:TextMark#T|Gtk.Gtk.TextMark.T]], where @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Moves mark to the new location where. Emits the "mark_set" signal as notification of the move.
  
  buffer : a GtkTextBuffer
  mark :   a GtkTextMark
  where :  new location for mark in buffer
  

==== :MoveMarkByName ====
'':MoveMarkByName(self @ [[#T|T]], name @ [[..:..:Std:String#T|Std.String.T]], where @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Moves the mark named name (which must exist) to location where. See gtk_text_buffer_move_mark() for details.
  
  buffer : a GtkTextBuffer
  name :   name of a mark
  where :  new location for mark
  

==== :PasteClipboard ====
'':PasteClipboard(self @ [[#T|T]], clipboard @ [[..:..:Gtk:Gtk:Clipboard#T|Gtk.Gtk.Clipboard.T]], override_location @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], default_editable @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Pastes the contents of a clipboard at the insertion point, or at override_location. (Note: pasting is asynchronous, that
  is, we'll ask for the paste data and return, and at some point later after the main loop runs, the paste data will be
  inserted.)
  
  buffer :            a GtkTextBuffer
  clipboard :         the GtkClipboard to paste from
  override_location : location to insert pasted text, or NULL for at the cursor
  default_editable :  whether the buffer is editable by default
  

==== :PlaceCursor ====
'':PlaceCursor(self @ [[#T|T]], where @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function moves the "insert" and "selection_bound" marks simultaneously. If you move them to the same place in two
  steps with gtk_text_buffer_move_mark(), you will temporarily select a region in between their old and new locations,
  which can be pretty inefficient since the temporarily-selected region will force stuff to be recalculated. This function
  moves them as a unit, which can be optimized.
  
  buffer : a GtkTextBuffer
  where :  where to put the cursor
  

==== :RegisterDeserializeFormat ====
'':RegisterDeserializeFormat(self @ [[#T|T]], mime_type @ [[..:..:Std:String#T|Std.String.T]], function @ [[..:..:Std:Function#T|Std.Function.T]], user_data @ [[..:..:Std:Address#T|Std.Address.T]], user_data_destroy @ [[..:..:Std:Function#T|Std.Function.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function registers a rich text deserialization function along with its mime_type with the passed buffer.
  
  buffer :            a GtkTextBuffer
  mime_type :         the format's mime-type
  function :          the deserialize function to register
  user_data :         function's user_data
  user_data_destroy : a function to call when user_data is no longer needed
  Returns :           the GdkAtom that corresponds to the newly registered format's mime-type.
  

==== :RegisterDeserializeTagset ====
'':RegisterDeserializeTagset(self @ [[#T|T]], tagset_name @ [[..:..:Std:String#T|Std.String.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function registers GTK+'s internal rich text serialization format with the passed buffer. See
  gtk_text_buffer_register_serialize_tagset() for details.
  
  buffer :      a GtkTextBuffer
  tagset_name : an optional tagset name, on NULL
  Returns :     the GdkAtom that corresponds to the newly registered format's mime-type.
  

==== :RegisterSerializeFormat ====
'':RegisterSerializeFormat(self @ [[#T|T]], mime_type @ [[..:..:Std:String#T|Std.String.T]], function @ [[..:..:Std:Function#T|Std.Function.T]], user_data @ [[..:..:Std:Address#T|Std.Address.T]], user_data_destroy @ [[..:..:Std:Function#T|Std.Function.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function registers a rich text serialization function along with its mime_type with the passed buffer.
  
  buffer :            a GtkTextBuffer
  mime_type :         the format's mime-type
  function :          the serialize function to register
  user_data :         function's user_data
  user_data_destroy : a function to call when user_data is no longer needed
  Returns :           the GdkAtom that corresponds to the newly registered format's mime-type.
  

==== :RegisterSerializeTagset ====
'':RegisterSerializeTagset(self @ [[#T|T]], tagset_name @ [[..:..:Std:String#T|Std.String.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function registers GTK+'s internal rich text serialization format with the passed buffer. The internal format does
  not comply to any standard rich text format and only works between GtkTextBuffer instances. It is capable of serializing
  all of a text buffer's tags and embedded pixbufs.
  This function is just a wrapper around gtk_text_buffer_register_serialize_format(). The mime type used for registering
  is "application/x-gtk-text-buffer-rich-text", or "application/x-gtk-text-buffer-rich-text;format=tagset_name" if a
  tagset_name was passed.
  The tagset_name can be used to restrict the transfer of rich text to buffers with compatible sets of tags, in order to
  avoid unknown tags from being pasted. It is probably the common case to pass an identifier != NULL here, since the NULL
  tagset requires the receiving buffer to deal with with pasting of arbitrary tags.
  
  buffer :      a GtkTextBuffer
  tagset_name : an optional tagset name, on NULL
  Returns :     the GdkAtom that corresponds to the newly registered format's mime-type.
  

==== :RemoveAllTags ====
'':RemoveAllTags(self @ [[#T|T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Removes all tags in the range between start and end. Be careful with this function; it could remove tags added in code
  unrelated to the code you're currently writing. That is, using this function is probably a bad idea if you have two or
  more unrelated code sections that add tags.
  
  buffer : a GtkTextBuffer
  start :  one bound of range to be untagged
  end :    other bound of range to be untagged
  

==== :RemoveSelectionClipboard ====
'':RemoveSelectionClipboard(self @ [[#T|T]], clipboard @ [[..:..:Gtk:Gtk:Clipboard#T|Gtk.Gtk.Clipboard.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Removes a GtkClipboard added with gtk_text_buffer_add_selection_clipboard().
  
  buffer :    a GtkTextBuffer
  clipboard : a GtkClipboard added to buffer by gtk_text_buffer_add_selection_clipboard()
  

==== :RemoveTag ====
'':RemoveTag(self @ [[#T|T]], tag @ [[..:..:Gtk:Gtk:TextTag#T|Gtk.Gtk.TextTag.T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Emits the "remove_tag" signal. The default handler for the signal removes all occurrences of tag from the given range.
  start and end don't have to be in order.
  
  buffer : a GtkTextBuffer
  tag :    a GtkTextTag
  start :  one bound of range to be untagged
  end :    other bound of range to be untagged
  

==== :RemoveTagByName ====
'':RemoveTagByName(self @ [[#T|T]], name @ [[..:..:Std:String#T|Std.String.T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Calls gtk_text_tag_table_lookup() on the buffer's tag table to get a GtkTextTag, then calls gtk_text_buffer_remove_tag
  ().
  
  buffer : a GtkTextBuffer
  name :   name of a GtkTextTag
  start :  one bound of range to be untagged
  end :    other bound of range to be untagged
  

==== :SelectRange ====
'':SelectRange(self @ [[#T|T]], ins @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], bound @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function moves the "insert" and "selection_bound" marks simultaneously. If you move them in two steps with
  gtk_text_buffer_move_mark(), you will temporarily select a region in between their old and new locations, which can be
  pretty inefficient since the temporarily-selected region will force stuff to be recalculated. This function moves them
  as a unit, which can be optimized.
  
  buffer : a GtkTextBuffer
  ins :    where to put the "insert" mark
  bound :  where to put the "selection_bound" mark
  

==== :Serialize ====
'':Serialize(self @ [[#T|T]], content_buffer @ [[..:..:Gtk:Gtk:TextBuffer#T|Gtk.Gtk.TextBuffer.T]], format @ [[..:..:Std:Object#T|Std.Object.T]], start @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], end @ [[..:..:Gtk:Gtk:TextIter#T|Gtk.Gtk.TextIter.T]], length @ [[..:..:Std:Object#T|Std.Object.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  This function serializes the portion of text between start and end in the rich text format represented by format.
  formats to be used must be registered using gtk_text_buffer_register_serialize_format() or
  gtk_text_buffer_register_serialize_tagset() beforehand.
  
  register_buffer : the GtkTextBuffer format is registered with
  content_buffer :  the GtkTextBuffer to serialize
  format :          the rich text format to use for serializing
  start :           start of block of text to serialize
  end :             end of block of test to serialize
  length :          return location for the length of the serialized data
  Returns :         the serialized data, encoded as format
  

==== :SetModified ====
'':SetModified(self @ [[#T|T]], setting @ [[..:..:Std:Symbol#T|Std.Symbol.T]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Used to keep track of whether the buffer has been modified since the last time it was saved. Whenever the buffer is
  saved to disk, call gtk_text_buffer_set_modified (buffer, FALSE). When the buffer is modified, it will automatically
  toggled on the modified bit again. When the modified bit flips, the buffer emits a "modified_changed" signal.
  
  buffer :  a GtkTextBuffer
  setting : modification flag setting
  

==== :SetText ====
'':SetText(self @ [[#T|T]], text @ [[..:..:Std:String#T|Std.String.T]], len @ [[..:..:Std:Integer#SmallT|Std.Integer.SmallT]]) : [[..:..:Std:Object#T|Std.Object.T]]''

  Deletes current contents of buffer, and inserts text instead. If len is -1, text must be nul-terminated. text must be
  valid UTF-8.
  
  buffer : a GtkTextBuffer
  text :   UTF-8 text to insert
  len :    length of text in bytes
  

==== New ====
''New(table : [[..:..:Gtk:Gtk:TextTagTable#T|Gtk.Gtk.TextTagTable.T]]) : [[# T| T]]''

  Creates a new text buffer.
  
  table :   a tag table, or NULL to create a new one
  Returns : a new text buffer
  

==== GetType ====
''GetType() : [[..:..:Gtk:GObject:Type#T|Gtk.GObject.Type.T]]''


