MOD Object;

IMP Type, Target;
IMP IO.File;
IMP IO.Terminal USE Out;
IMP Std.String;

DEF T <- <[Type.T, Target.T]
	ns, name, cname, parent,
	methods, ctors,
	ctype, rtype,
	ctor_prefix
>;

DEF PrefixLength(cname) (
	VAR n <- cname:length;
	EVERY "A" <= cname:chars <= "Z" DO n <- n + 1;
	--Out:writes("PrefixLength(", cname, ") = ", n, "\n");
	RET n;
);

DEF New!(ns, name, cname, parent) (
	VAR t <- T();
	t:ns <- ns;
	t:name <- name;
	t:cname <- cname;
	t:parent <- parent;
	t:methods <- [];
	t:ctors <- [];
	t:rtype <- "Gtk$" + ns + "$" + name + "$T";
	t:ctype <- cname + " *";
	Type.Define(cname + "*", t);
	t:queue;
	t:ctor_prefix <- PrefixLength(cname);
	RET t;
);

VAR gobject <- T();
gobject:ns <- "GObject";
gobject:name <- "Object";
gobject:cname <- "GObject";
gobject:rtype <- "Gtk$GObject$Object$T";
gobject:ctype <- "GObject*";
Type.Define("GObject*", gobject);

TO :addmethod(t@T, name, cname) (
	VAR method <- Type.Method(name, cname, []);
	method:addparam("self", t:cname + "*");
	t:methods:put(method);
	RET method;
);

TO :addctor(t@T, cname) (
	VAR name <- "";
	VAR i <- t:ctor_prefix, n <- cname:length;
	cname[i] = "_" => (i <- i + 1);
	name <- name + String.Chr(String.Ord(cname[i]) - 32);
	REP (
		i <- i + 1;
		UNTIL i > n;
		cname[i] = "_" => (
			i <- i + 1;
			name <- name + String.Chr(String.Ord(cname[i]) - 32);
		) // (
			name <- name + cname[i];
		);
	);
	--Out:writes("Adding constructor ", cname, " -> ", name, "\n");
	VAR method <- Type.Method(name, cname, []);
	t:ctors:put(method);
	RET method;
);

DEF fakeparents <- {NIL, "GInitiallyUnowned", "GObject"};

TO :parents(t@T) (
	VAR parent <- t:parent;
	REP (UNTIL fakeparents[parent];
		parent <- (SUSP Type.Lookup(parent + "*")):parent;
	);
	RET gobject;
);

TO :precall(t@T, name, arg) [
	t:ctype + " " + name + " = ((Gtk$GObject$Object_t *)" + arg + ".Val)->Handle;"
];

TO :return(t@T, result) [
	"if (" + result + " == 0) return FAILURE;",
	"Result->Val = Gtk$GObject$gtk_to_riva(" + result + ");",
	"return SUCCESS;"
];

TO :process(t@T) (
	VAR base <- t:ns + "/" + t:name;
	VAR cfile <- File.Open("src/" + base + ".c", File.WRITE + File.TEXT);
	cfile:writes("#include <Gtk/", base, ".h>\n\n");
	cfile:writes("TYPE(T");
	EVERY cfile:writes(", ", t:parents:rtype);
	cfile:writes(");\n\n");
	VAR method, param, i, returntype, types, names, n, params, ctor;
	EVERY ctor <- t:ctors:values DO (
		params <- ctor:params;
		n <- params:size;
		types <- params:map(<p> Type.Lookup(p:type));
		names <- params:map(:name);
		cfile:writes("GLOBAL_FUNCTION(", ctor:name, ", ", n, ") {\n");
		EVERY i <- 1:to(n) DO (
			EVERY cfile:writes("\t", types[i]:precall(names[i], "Args[" + i@String.T + "]"):values, "\n");
		);
		cfile:writes("\tGtk$GObject$Object_t *result = new(Gtk$GObject$Object_t);\n");
		cfile:writes("\tresult->Type = T;\n");
		cfile:writes("\tresult->Handle = ", ctor:cname, "(");
		cfile:write(names[1]) => EVERY i <- 2:to(n) DO cfile:writes(", ", names[i]);
		cfile:write(");\n");
		cfile:write("\tResult->Val= result;\n");
		cfile:write("\treturn SUCCESS;\n");
		cfile:write("};\n\n");
	);
	EVERY method <- t:methods:values DO (
		params <- method:params;
		n <- params:size;
		types <- params:map(<p> Type.Lookup(p:type));
		names <- params:map(:name);
		cfile:writes("METHOD(\"", method:name, "\", TYP, T");
		EVERY cfile:writes(", TYP, ", types[2:to(n)]:rtype);
		cfile:write(") {\n");
		EVERY i <- 1:to(n) DO (
			EVERY cfile:writes("\t", types[i]:precall(names[i], "Args[" + i@String.T + "]"):values, "\n");
		);
		cfile:write("\t");
		returntype <- Type.Lookup(method:type);
		returntype:ctype ~= "void" => cfile:writes(returntype:ctype, " result = ");
		cfile:writes(method:cname, "(self");
		EVERY i <- 2:to(n) DO cfile:writes(", ", names[i]);
		cfile:writes(");\n");
		EVERY i <- 1:to(n) DO (
			EVERY cfile:writes("\t", types[i]:postcall(names[i], "Args[" + i@String.T + "]"):values, "\n");
		);
		returntype:ctype ~= "void" => (
			EVERY cfile:writes("\t", returntype:return("result"):values, "\n");
		);
		cfile:write("\treturn SUCCESS;\n");
		cfile:write("};\n\n");
	);
	cfile:close;
	VAR hfile <- File.Open("inc/" + base + ".h", File.WRITE + File.TEXT);
	hfile:writes("#ifndef ", t:ns, "_", t:name, "_H\n");
	hfile:writes("#define ", t:ns, "_", t:name, "_H\n\n");
	VAR parent <- t:parents;
	hfile:writes("#include <Gtk/", parent:ns, "/", parent:name, ".h>\n\n");
	hfile:writes("extern Std$Type_t ", t:rtype, "[];\n\n");
	hfile:write("#endif\n");
	hfile:close;
);

END Object.
